// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE
function setConnectionContext(connectionContext, gattServer) {
	return new Promise((resolve, reject) => {
		if (connectionContext == null) {
			reject('No connection context provided');
		}
		status = gattServer.connected ? 'Connected' : 'NotConnected';
		connectionContext.set('ConnectionStatus', status);
		mx.data.commit({
			mxobj: connectionContext,
			callback: function() {
			},
			error: function(e) {
				alert('Could not commit object: ' + e);
			}
		});
	});
}
// END EXTRA CODE

/**
 * @param {string} primaryServiceUUID
 * @param {string} optionalServiceUUID
 * @param {MxObject} connectionContext
 * @returns {Promise.<boolean>}
 */
export async function DeviceConnect(primaryServiceUUID, optionalServiceUUID, connectionContext) {
	// BEGIN USER CODE
	try{
		if(!navigator.bluetooth) {
			return Promise.reject('This device does not support bluetooth');
		}
			
		return new Promise((resolve, reject) => {
			const gattServer = window.gattServer;
			if(gattServer && gattServer.connected){
				resolve(true);
			} else{ 
				navigator.bluetooth.requestDevice({
					filters: [{ services: [primaryServiceUUID] }],
					optionalServices: optionalServiceUUID.split(',')
				}).then((device) => {
					device.addEventListener('gattserverdisconnected', (event) => {
						setConnectionContext(connectionContext, device.gatt);
					});
					return device.gatt.connect()
				}).then((server) => {
					console.log(server);
					window.gattServer = server;
					window.characteristics = [];
					console.log('Connected to new server');
					resolve(server.connected);
					return setConnectionContext(connectionContext, server);
				}).catch(error => {
    				resolve(false);
  				});
			}
		});
	} catch (error) {
		return Promise.reject(error);
	}
	// END USER CODE
}
